#define _XOPEN_SOURCE 700

#include <stdio.h>  // printf(), fprintf(), FILE, fopen(), fread(), fclose()
#include <stdlib.h> // EXIT_SUCCESS, EXIT_FAILURE, size_t
#include <stddef.h> // offsetof()
#include <stdint.h> // uint8_t, uint32_t
#include <string.h> // memcpy()

#include "mailbox.h"  // mbox_open(), qpu_enable(), mem_alloc(), mem_lock(), mapmem()



#define QPU_CODEFILE    "./vpm_test.qbin"
#define NUM_QPUS        (12)
#define NUM_UNIFORMS    (1)
#define NUM_MESSAGES    (2)
#define GPU_MEM_FLAG    (0xc) // cached
#define GPU_MEM_MAP     (0x0) // cached

#define QPU_CODE_BYTECOUNT (10000)
#define TEXT_WORDSIZE   (8)   // 8 words (32 byte) for each QPU. Total of 384 bytes processed





struct GPUMemoryMap {
  uint32_t qpuCode[QPU_CODE_BYTECOUNT / sizeof(uint32_t)];
  uint32_t data[ TEXT_WORDSIZE * NUM_QPUS ];  // accessed via VPM, divided
  uint32_t uniforms[NUM_QPUS * NUM_UNIFORMS];
  uint32_t messages[NUM_QPUS * NUM_MESSAGES];
};





/* Prints each byte of the input array as a hex encoded number.
 * Line break at each 16th number.
 */
void print_hex(const uint8_t *input, size_t size)
{
  for (int i = 0; i < size; i++) {
    printf("%.2x", input[i]);

    if ((i+1) % 16 == 0) {
      printf("\n");
    }
  }
  printf("\n");
}



/* Reads the content of 'qpuCodeFile' into 'qpuCode'.
 */
void load_qpu_code(const char *qpuCodeFile, uint32_t *qpuCode)
{
  FILE *file_in = fopen(qpuCodeFile, "r");
  if (!file_in) {
    fprintf(stderr, "ERROR. Failed to open %s.\n", qpuCodeFile);
    exit(EXIT_FAILURE);
  }

  fread(qpuCode, sizeof(uint32_t), QPU_CODE_BYTECOUNT / sizeof(uint32_t) , file_in);
  fclose(file_in);
}



/*
 */
int main(int argc, char **argv)
{
  uint32_t localQPUCode[QPU_CODE_BYTECOUNT / sizeof(uint32_t)];

  uint8_t text[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                    0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};


  uint32_t totalBytecount =
    QPU_CODE_BYTECOUNT +   // Bytecount of QPU Code
    TEXT_WORDSIZE * NUM_QPUS * sizeof(uint32_t) + // Bytecount of data
    NUM_UNIFORMS * sizeof(uint32_t) +   // Bytecount of Uniforms
    NUM_MESSAGES * sizeof(uint32_t);    // Bytecount of Messages



  // Load QPU code, open mailbox for GPU communication and enable GPU
  load_qpu_code(QPU_CODEFILE, localQPUCode);

  int32_t mailbox = mbox_open();

  if (qpu_enable(mailbox, 1)) {
    fprintf(stderr, "ERROR. Unable to enable GPU. Executed as superuser?\n");
    return EXIT_FAILURE;
  }

  // Allocate and lock memory on GPU, then create a mirror memory on CPU
  uint32_t gpu_MemoryHandle = mem_alloc(mailbox, totalBytecount, 4096, GPU_MEM_FLAG);
  uint32_t gpu_MemoryBase = mem_lock(mailbox, gpu_MemoryHandle);
  void*    cpu_MemoryBase = mapmem(gpu_MemoryBase + GPU_MEM_MAP, totalBytecount);

  struct GPUMemoryMap *cpu_map = (struct GPUMemoryMap*) cpu_MemoryBase;

  unsigned vc_code = gpu_MemoryBase + offsetof(struct GPUMemoryMap, qpuCode);
  unsigned vc_data = gpu_MemoryBase + offsetof(struct GPUMemoryMap, data);
  unsigned vc_uni  = gpu_MemoryBase + offsetof(struct GPUMemoryMap, uniforms);
  unsigned vc_msg  = gpu_MemoryBase + offsetof(struct GPUMemoryMap, messages);

  memcpy(cpu_map->qpuCode, localQPUCode, QPU_CODE_BYTECOUNT);
  memcpy(cpu_map->data, text, TEXT_WORDSIZE*sizeof(uint32_t)*NUM_QPUS);

  for (int i=0; i < NUM_QPUS; i++) {
    cpu_map->uniforms[i*NUM_UNIFORMS+0] = vc_data + TEXT_WORDSIZE*sizeof(uint32_t)*i;

    cpu_map->messages[i*NUM_MESSAGES+0] = vc_uni + NUM_UNIFORMS*sizeof(uint32_t)*i;
    cpu_map->messages[i*NUM_MESSAGES+1] = vc_code;
  }


  // Start execution
  execute_qpu(mailbox, NUM_QPUS, vc_msg, 1, 10000);


  // Fetch the results
  memcpy( text, cpu_map->data, TEXT_WORDSIZE*sizeof(uint32_t)*NUM_QPUS );


  // Free memory and close pipes
  unmapmem(cpu_MemoryBase, totalBytecount);
  mem_unlock(mailbox, gpu_MemoryHandle);
  mem_free(mailbox, gpu_MemoryHandle);
  qpu_enable(mailbox, 0);
  mbox_close(mailbox);


  // Print results
  print_hex(text, sizeof(text));


  return EXIT_SUCCESS;
}

